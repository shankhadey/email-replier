"""
Google OAuth2 authentication â€” multi-user.

Tokens are stored per-user in the DB (no credentials.json / token.json files).
Client credentials come from GOOGLE_CLIENT_ID / GOOGLE_CLIENT_SECRET env vars.
"""

import os
import threading
from datetime import datetime, timedelta, timezone
from typing import Optional

from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import Flow
from googleapiclient.discovery import build

import database as db

SCOPES = [
    "openid",
    "https://www.googleapis.com/auth/userinfo.email",
    "https://www.googleapis.com/auth/userinfo.profile",
    "https://www.googleapis.com/auth/gmail.modify",
    "https://www.googleapis.com/auth/calendar.readonly",
    "https://www.googleapis.com/auth/drive.readonly",
]


def _client_config() -> dict:
    """Build the OAuth client config dict from environment variables."""
    base_url = os.environ.get("APP_BASE_URL", "http://localhost:8000").rstrip("/")
    return {
        "web": {
            "client_id": os.environ["GOOGLE_CLIENT_ID"],
            "client_secret": os.environ["GOOGLE_CLIENT_SECRET"],
            "auth_uri": "https://accounts.google.com/o/oauth2/auth",
            "token_uri": "https://oauth2.googleapis.com/token",
            "redirect_uris": [base_url + "/auth/callback"],
        }
    }


# Per-user locks â€” prevent concurrent token refresh races
_token_locks: dict[str, threading.Lock] = {}
_token_locks_mutex = threading.Lock()


def _get_token_lock(user_id: str) -> threading.Lock:
    with _token_locks_mutex:
        if user_id not in _token_locks:
            _token_locks[user_id] = threading.Lock()
        return _token_locks[user_id]


def create_oauth_flow() -> Flow:
    """Create a new OAuth flow (state generated by caller)."""
    config = _client_config()
    base_url = os.environ.get("APP_BASE_URL", "http://localhost:8000").rstrip("/")
    flow = Flow.from_client_config(config, scopes=SCOPES)
    flow.redirect_uri = base_url + "/auth/callback"
    return flow


def credentials_to_dict(creds: Credentials) -> dict:
    """Serialize credentials without embedding client_id/secret (re-injected from env)."""
    expiry_str = None
    if creds.expiry:
        if creds.expiry.tzinfo is None:
            expiry_str = creds.expiry.replace(tzinfo=timezone.utc).isoformat()
        else:
            expiry_str = creds.expiry.isoformat()
    return {
        "token": creds.token,
        "refresh_token": creds.refresh_token,
        "token_uri": creds.token_uri or "https://oauth2.googleapis.com/token",
        "scopes": list(creds.scopes) if creds.scopes else SCOPES,
        "expiry": expiry_str,
    }


def get_credentials(user_id: str) -> Credentials:
    """
    Load credentials for the given user from DB, refresh if expired, save back.
    Raises ValueError if no token found.
    """
    lock = _get_token_lock(user_id)
    with lock:
        token_dict = db.load_token(user_id)
        if token_dict is None:
            raise ValueError(f"No token found for user {user_id}")

        client_id = os.environ["GOOGLE_CLIENT_ID"]
        client_secret = os.environ["GOOGLE_CLIENT_SECRET"]

        # Parse expiry
        expiry = None
        if token_dict.get("expiry"):
            try:
                expiry = datetime.fromisoformat(token_dict["expiry"])
                if expiry.tzinfo is None:
                    expiry = expiry.replace(tzinfo=timezone.utc)
            except ValueError:
                expiry = None

        creds = Credentials(
            token=token_dict.get("token"),
            refresh_token=token_dict.get("refresh_token"),
            token_uri=token_dict.get("token_uri", "https://oauth2.googleapis.com/token"),
            client_id=client_id,
            client_secret=client_secret,
            scopes=token_dict.get("scopes", SCOPES),
            expiry=expiry,
        )

        # Check expiry ourselves with timezone-aware datetimes to avoid
        # the naive-vs-aware comparison bug in older google-auth versions.
        expiry = creds.expiry
        if expiry is not None and expiry.tzinfo is None:
            expiry = expiry.replace(tzinfo=timezone.utc)
        token_expired = expiry is not None and datetime.now(timezone.utc) >= expiry - timedelta(seconds=60)
        token_missing = not creds.token

        if token_expired or token_missing:
            if creds.refresh_token:
                creds.refresh(Request())
                db.save_token(user_id, credentials_to_dict(creds))
            else:
                raise ValueError(f"Token for user {user_id} is invalid and cannot be refreshed")

        return creds


def is_authorized(user_id: str) -> bool:
    """Check if a valid token exists for the given user."""
    try:
        get_credentials(user_id)
        return True
    except Exception:
        return False


def get_gmail_service(user_id: str):
    return build("gmail", "v1", credentials=get_credentials(user_id))


def get_calendar_service(user_id: str):
    return build("calendar", "v3", credentials=get_credentials(user_id))


def get_drive_service(user_id: str):
    return build("drive", "v3", credentials=get_credentials(user_id))
